#!/usr/bin/env bash
set -euo pipefail

SLOTS_PER_EPOCH="{{ .Validator.SlotsPerEpoch }}"
TICKS_PER_SLOT="{{ .Validator.TicksPerSlot }}"
COMPUTE_UNIT_LIMIT="{{ .Validator.ComputeUnitLimit }}"
LEDGER_LIMIT_SIZE="{{ .Validator.LedgerLimitSize }}"
PROGRAM_SO_PATH="{{ .Validator.ProgramDeploy.SOPath }}"
PROGRAM_ID_KEYPAIR_PATH="{{ .Validator.ProgramDeploy.ProgramIDKeypairPath }}"
UPGRADE_AUTHORITY_PATH="{{ .Validator.ProgramDeploy.UpgradeAuthorityPath }}"

supports_flag() {
  local flag="$1"
  local help_output
  help_output="$(solana-test-validator --help 2>&1 || true)"
  grep -q -- "$flag" <<<"$help_output"
}

# Clone a program from clone_programs using --clone-upgradeable-program.
# This works for both upgradeable and legacy BPF programs.
clone_program_auto() {
  local pubkey="$1"
  if supports_flag --clone-upgradeable-program; then
    args+=(--clone-upgradeable-program "$pubkey")
  else
    echo "warning: --clone-upgradeable-program not supported; skipping $pubkey" >&2
  fi
}

wait_for_local_rpc() {
  local endpoint="http://127.0.0.1:8899"
  local payload='{"jsonrpc":"2.0","id":1,"method":"getHealth"}'

  for _ in $(seq 1 90); do
    if ! kill -0 "$validator_pid" 2>/dev/null; then
      echo "validator exited before RPC became healthy" >&2
      return 1
    fi
    if curl -sS -m 2 -H "Content-Type: application/json" -d "$payload" "$endpoint" | grep -q '"result":"ok"'; then
      return 0
    fi
    sleep 2
  done

  echo "validator RPC did not become healthy in time for startup program deploy" >&2
  return 1
}

deploy_program_if_configured() {
  if [[ -z "$PROGRAM_SO_PATH$PROGRAM_ID_KEYPAIR_PATH$UPGRADE_AUTHORITY_PATH" ]]; then
    return 0
  fi

  if [[ -z "$PROGRAM_SO_PATH" || -z "$PROGRAM_ID_KEYPAIR_PATH" || -z "$UPGRADE_AUTHORITY_PATH" ]]; then
    echo "startup program deploy config is incomplete; require program .so, program id keypair, and upgrade authority keypair" >&2
    return 1
  fi
  if [[ ! -f "$PROGRAM_SO_PATH" ]]; then
    echo "startup program .so not found: $PROGRAM_SO_PATH" >&2
    return 1
  fi
  if [[ ! -f "$PROGRAM_ID_KEYPAIR_PATH" ]]; then
    echo "program id keypair not found: $PROGRAM_ID_KEYPAIR_PATH" >&2
    return 1
  fi
  if [[ ! -f "$UPGRADE_AUTHORITY_PATH" ]]; then
    echo "upgrade authority keypair not found: $UPGRADE_AUTHORITY_PATH" >&2
    return 1
  fi

  echo "waiting for local validator RPC before program deploy..."
  if ! wait_for_local_rpc; then
    return 1
  fi

  local authority_pubkey
  authority_pubkey="$(solana address --keypair "$UPGRADE_AUTHORITY_PATH")"
  local program_pubkey
  program_pubkey="$(solana address --keypair "$PROGRAM_ID_KEYPAIR_PATH")"
  echo "airdropping SOL to upgrade authority $authority_pubkey"
  solana airdrop 100 "$authority_pubkey" -u http://127.0.0.1:8899 >/dev/null

  echo "deploying program $program_pubkey from $PROGRAM_SO_PATH"
  solana program deploy \
    -u http://127.0.0.1:8899 \
    "$PROGRAM_SO_PATH" \
    --program-id "$PROGRAM_ID_KEYPAIR_PATH" \
    --upgrade-authority "$UPGRADE_AUTHORITY_PATH" \
    --keypair "$UPGRADE_AUTHORITY_PATH"
}

{{- if .Validator.AirdropAccounts }}
airdrop_configured_accounts() {
  echo "waiting for local validator RPC before airdrops..."
  if ! wait_for_local_rpc; then
    echo "warning: validator did not become ready; skipping airdrops" >&2
    return 0
  fi
{{- range .Validator.AirdropAccounts }}
  echo "airdropping {{ .Amount }} SOL to {{ .Address }}"
  solana airdrop {{ .Amount }} "{{ .Address }}" -u http://127.0.0.1:8899 \
    || echo "warning: airdrop to {{ .Address }} failed" >&2
{{- end }}
}
{{- end }}

LEDGER_DIR="/var/lib/solana/ledger"

{{- if .Validator.ForceReset }}
# --reset was passed to sol-cloud deploy; wipe the ledger contents so --clone
# and other startup args are not silently ignored by solana-test-validator.
# We clear the contents rather than the directory itself because the ledger
# path is a volume mount point and cannot be removed.
echo "force reset: clearing existing ledger data"
find "${LEDGER_DIR:?}" -mindepth 1 -delete 2>/dev/null || true
{{- end }}

# Check if ledger directory has existing data
if [ -d "$LEDGER_DIR" ] && [ "$(ls -A $LEDGER_DIR 2>/dev/null)" ]; then
  echo "Existing ledger data found, preserving state (skipping --reset)"
  RESET_FLAG=""
else
  echo "No existing ledger data, starting fresh (using --reset)"
  RESET_FLAG="--reset"
fi

args=(
  --ledger /var/lib/solana/ledger
  --bind-address 0.0.0.0
  $RESET_FLAG
  --url https://api.mainnet-beta.solana.com
  --limit-ledger-size "$LEDGER_LIMIT_SIZE"
  --slots-per-epoch "$SLOTS_PER_EPOCH"
)

if supports_flag --ticks-per-slot; then
  args+=(--ticks-per-slot "$TICKS_PER_SLOT")
else
  echo "warning: this solana-test-validator build does not support --ticks-per-slot; continuing without it" >&2
fi

if supports_flag --compute-unit-limit; then
  args+=(--compute-unit-limit "$COMPUTE_UNIT_LIMIT")
else
  echo "warning: this solana-test-validator build does not support --compute-unit-limit; continuing without it" >&2
fi

{{- range .Validator.ClonePrograms }}
clone_program_auto "{{ . }}"
{{- end }}

{{- range .Validator.CloneAccounts }}
if supports_flag --clone; then
  args+=(--clone "{{ . }}")
else
  echo "warning: this solana-test-validator build does not support --clone; continuing without clone accounts" >&2
fi
{{- end }}

{{- range .Validator.CloneUpgradeablePrograms }}
if supports_flag --clone-upgradeable-program; then
  args+=(--clone-upgradeable-program "{{ . }}")
else
  echo "warning: this solana-test-validator build does not support --clone-upgradeable-program; continuing without clone upgradeable programs" >&2
fi
{{- end }}

solana-test-validator "${args[@]}" &
validator_pid=$!
nginx_pid=""

cleanup() {
  kill "${validator_pid:-}" "${nginx_pid:-}" 2>/dev/null || true
}

trap cleanup INT TERM EXIT

if ! deploy_program_if_configured; then
  exit 1
fi

{{- if .Validator.AirdropAccounts }}
airdrop_configured_accounts
{{- end }}

nginx -g 'daemon off;' &
nginx_pid=$!

wait -n "$validator_pid" "$nginx_pid"
exit_code=$?
cleanup
wait "$validator_pid" "$nginx_pid" 2>/dev/null || true
exit "$exit_code"
